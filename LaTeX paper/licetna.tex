\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{anyfontsize}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage[romanian]{babel}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows, shapes.gates.logic.US, calc}
\usetikzlibrary{positioning}
\usetikzlibrary {circuits.logic.CDH} 
\usepackage{quiver} 
\usepackage{fancyhdr}
\usepackage{listings}
\renewcommand{\lstlistingname}{Exemplu de cod}
%\usepackage{helvet}
%\renewcommand{\familydefault}{\sfdefault}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=20mm,
 right=20mm,
 top=25mm,
 bottom=20mm,
 headheight = 10mm,
 }
\setlength\parindent{15mm}

\pagestyle{fancy}
%... then configure it.
\fancyhead{} % clear all header fields
\setlength{\headsep}{0.65in}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\fancyfoot[CE,CO]{\thepage}
\fancyhead[LE, LO]{

Departamentul de Ingineria Sistemelor

2020-2024

Bulzan Dan-Alexandru

Microprocesorul RISC-V}

\fancyhead[RE, RO]{
\includegraphics{Picture1.jpg}
}

\begin{document}
\fontsize{20pt}{18pt}\selectfont
\title{\textbf{Microprocesorul RISC-V}}

\date{}
\maketitle

\vspace*{150mm}


\begingroup
    \fontsize{14pt}{12pt}\selectfont
	\textbf{Canditat: Dan-Alexandru Bulzan}
	\bigbreak
	\textbf{Coordonator științific: Ș.l.dr.ing Eugen-Horațiu Gurban}
\endgroup


\vspace*{\fill}
\begin{center}
\fontsize{14pt}{12pt}\selectfont
Sesiune: Iunie 2024
\end{center}


\newpage
\section{\centering INTRODUCERE}
\bigbreak
\subsection{SCOPUL ȘI MOTIVAȚIA LUCRĂRII}
\setstretch{1.2}

Implementarea personală a setului de instrucțiuni RISC-V, s-a născut din dorința de a realiza ceea ce poate fi considerat nimic mai puțin decât un apogeu al metodelor științifice din ultimul secol, și anume, procesorul.

Aceste dispozitive electronice reprezintă fundamentul tuturor științelor informatice, grație capacității computaționale intrinsece. Procesoarele, indiferent de gradul lor de specializare, au fost și rămân nucleul unei revoluții tehnologice pe care nici din pură ignoranță nu o putem omite, aceasta fiind prezentă până și în cele mai mundane aspecte ale vieții cotidiene.
Scopul acestei lucrări este de a traversa universul digital, începând din rădăcinile sale analogice, ajungând într-un final la organizarea ierarhică a numeroaselor entități digitale în a căror întregime se constituie un sistem de calcul complet funcțional.

Adesea este usor sa ne pierdem în complexitățiile ascunse printre miile de porți logice, un veritabil microcosm digital, însă prin mijloacele abstractizării și modularizării, proiectarea unui procesor devine nimic mai mult decât o modelare regulată a unui sistem descriptibil de operațiile algebrei Booleane. Pe parcursul lucrării, se va prezenta de asemenea o simplă implementare didactică a modulului de memorie cache, un component digital de o importanță deosebită, precum si problematica care cere o astfel de soluție.

Implementarea va fi realizată în limbajul de descriere hardware VHDL, entitățile urmând să fie simulate prin intermediul Vivado, soluție de design și sinteză hardware oferită de Advanced Micro Devices.

\begin{center}
\vspace*{40mm}
DE CONTINUAT
\end{center}

\newpage
\section{\centering STUDIU BIBLIOGRAFIC}
\bigbreak
\subsection{ARHITECTURA RISC}
Înainte de realizarea unei analize asupra stadiului de dezvoltare și implementare al setului de instrucțiuni RISC-V, întelegerea locului pe care filozofia RISC o are în disciplina arhitecturii calculatoarelor, este de o importantă deosebită.

Acronimul RISC, face referintă la \textit{reduced instruction set computer} sau calculator cu set de instrucțiuni reduse. Un microprocesor care implementează o astfel de filozofie, utilizează un set de instructiuni compact și puternic optimizat, garantând execuția rapidă a fiecărei instrucțiuni. Prin urmare, o caracteristică a acestei abordări, este faptul că microprocesorul va fi nevoit să execute un numar mai ridicat de instrucțiuni pentru a realiza aceleași operații efectuate de un calculator cu set de instrucțiuni complex, cunoscut și sub acronimul de \textit{CISC}, printr-un număr observabil mai redus de instrucțiuni.

De-a lungul timpului, începând cu întemeierea arhitecturii RISC, au fost conceput mai multe seturi de instrucțiuni relevante, printre acestea enumerându-se următoarele: MIPS, ARM cât și setul care va reprezenta arhitectura procesorului implementat pe decursul acestei lucrari, RISC-V.

\subsection{FAMILIA SETURILOR DE INSTRUCȚIUNI ARM}
Seturile de instrucțiuni care aparțin familiei ARM sunt fără echivoc cele mai de succes dintre toate seturile aferente arhitecturii RISC. Acest succes este în mare parte datorat costurilor reduse de producție cât și eficienței computaționale ridicate. Dispozitivele dezvoltate în jurul microprocesoarelor ARM au un grade de utilitate ridicat, prezența acestora facându-se simțită într-o vastă gamă de domenii. Cele mai evidente utilizări sunt reprezentate de telefoanele mobile și computerele personale, însă arhitectura ARM a reușit să se etaleze până și în domeniul computerelor de înaltă performanță, prin intermediul supercomputerului Fugaku.

Arhitectura ARM s-a bucurat de decenii întregi de dezvoltare și prin urmare de vaste îmbunătățiri, ajungând la un grad înalt de maturitate, lucru care-i definește utilitate contemporană.

\subsection{SETUL DE INSTRUCȚIUNI RISC-V}
Setul de instrucțiuni RISC-V reprezintă una dintre cele mai noi adiții aduse mulțimii familiilor arhitecturii RISC. Acest ISA nu funcționează pe baza unei licențe de utilizare, fiind un standard deschis, este permisă folosirea sa tuturor entităților legale sau persoanelor care doresc implementarea unui microprocesor sau a unui sistem integrat bazându-se pe acest set.

\subsection{IMPLEMENTĂRI  RISC-V}
Datorită proliferării lipsite de licentă cât și împărțirii setului în extensii, se poate observa un constant flux de implementări, variind de la simple exemple didactice la sisteme cu module multicip complexe. Numeroase programe de studii care au ca scop dezvoltarea cunoștiintelor despre organizarea calculatoarelor, obișnuiesc să prezinte ca suport didactic implementări succinte ale unui nucleu RISC-V. Fiecare asemeni implementare prezintă ușoare diferențe arhitectural-organizatorice față de omologi săi. Aceste diferențe sunt produsul faptului că arhitectura RISC-V nu îngrădește utilizatorii săi într-o specifică topologie de organizare a modulelor care constituie în intregimea lor un microprocesor. Fiecare utilizator are astfel liber arbitru în definirea propriei organizări, atât timp cât respectă setul de instrucțiuni.

Se disting astfel două mari tipuri de microprocesoare RISC-V, ale căror implementări sunt disponibile spre analiză. Prima și cea mai comună este reprezentată de microprocesorul RISC-V SCP sau \textit{single cycle processor}, cea de a doua purtând numele de \textit{multi-cycle processor} sau pe scurt, MCP.


\begin{center}
\vspace*{60mm}
DE CONTINUAT
\end{center}

\newpage
\section{\centering FUNDAMENTARE TEORETICĂ}
\bigbreak
\subsection{GESTIONAREA COMPLEXITĂȚII}
Cand vine vorba de modelara unui sistem computațional de o complexitate ridicată, este de preferat să avem anumite fundamente în implementare, pe care să ne putem baza fără echivoc. În lipsa acestor principii este adesea usor să ne pierdem în complexitatea sistemului, rezultând astfel posibile erori care-și vor face simțită prezența în produsul final.

\subsubsection{ABSTRACTIZARE}
Abstractizarea este opusul specificității. Din punct de vedere conceptual, actul de abstractizare, indiferent de suportul teoretic asupra căruia este aplicat, ajută la simplificarea unei probleme a cărei complexități ar fi de altfel prea greu de tratat. Prin abstractizare, detalile de la un anumit nivel logic al unui sistem, sunt redate sumar și considerate ca atare de catre nivelele logice superioare.


Acest lucru poate fi observat într-o multitudine de domenii, de la arhitectura calculatoarelor la studiul fiziologiei medicale. De exemplu, bazându-ne pe cel din urmă domeniu enumerat, modul de funcționare a unui organism viu poate fi privit din mai multe perspective de abstractizare, începând de la interacțiunile biochimice si biomecanice de la nivelul unei celule, trecând pe urmă la modul în care aceste celule interacționeaza între ele formând variate țesuturi, ajungând într-un final la nivelul de abstracție al țesuturilor care împreună formează organe, fiecare nivel implicându-l direct pe precedentul său.

\subsubsection{MODULARITATE}
Modularizarea definește modul în care un sistem computațional va fi divizat în numeroase parți de sine stătătoare, acum numite module, fiecare cu un rol și o interfață de utilizare concis definită. Aceste module permit astfel reutilizarea  entităților pe care le definesc, ne mai fiind nevoie de irosirea unei perioade mari de timp cu diverse noi implementării care sunt congruente cu un modul deja existent. Modularizarea ne permite de asemenea înlocuirea unor părți ale sistemului nostru cu altele de o eficiență mai ridicată, cât timp acestea respectă aceeași interfață pentru a permite comunicarea cu modulele adiacente.

\subsubsection{IERARHIZARE}
Ierarhizarea implică ordonarea într-o arhitectură a modulelor anterior definite. Arhitectura, în cazul nostru, va fi reprezentată de modul de organizare a microprocesorului ce urmează a fi dezvoltat, microarhitectura acestuia. Organizarea ierarhică implică modularitatea dar vice-versa nu este mereu valabilă, modulele putând exista pe același nivel ierarhic, nefiind, prin urmare, subordonate unul altuia.

\subsection{ABSTRACȚIA NUMERICĂ}
Pentru a produce un rezultat de o oarecare utilitate, sistemele computaționale au nevoie de date. Aceste date sunt complet irelevante cât timp nu respectă un mod de reprezentare util sistemului. De asemenea, este importat de luat in considerare faptul ca datele hrănite pot avea semnificații diverse, complet obtuze una față de cealaltă.


Problema reprezentării datelor primește o importanță specială, deosebită chiar, dând naștere următoarei multitudini de întrebări, \textit{care este este modul corect de reprezentare}; \textit{cum asigurăm coerența datelor cu analizarea acestora de către sistemul de calcul}; \textit{cum ne asigurăm ca datele indiferent formatului ligibil uman, nu sunt iligibile procesorului.}


Pentru a răspunde pe deplin, trebuie mai întâi să definim tipul datelor pe care microprocesorul le va accepta. Este rapid evident, din natura sistemului, că datele trebuie să fie numerice. Însă, nu la fel de evident este modul în care aceste numere vor fi reprezentate pentru a suporta toate operațiile admisibile de un motor logic-aritmetic.

Cea mai reprezentativă caracteristică a unui sistem de numerație este numărul de simboluri unice utilizate de acesta. Numărul de simboluri poartă numele de radix și este congruent cu conceptul de bază numerică. Valoarea minimă pe care radix-ul unui sistem de numerație o poate lua este \textit{1}, corespunzând unui sistem cu un singur simbol, fiecare numâr continând \textit{n+1} simboluri față de precedentul sau \textit{n}. Însă, trecând cu vederea această anomalie numerică, bazele care vor reprezenta suportul matematic al acestei lucrări sunt cea decimală, cea hexadecimală și cea binară. În Tabela \ref{Tabela:1} se pot observa bazele anterior menționate, însoțite de simbolurile aferente cât și de un exemplu reprezentativ.

\begin{table}[h]
\centering
\caption{Intervalul de simboluri posibile, raportate la baza numerică }
\label{Tabela:1}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Radix & Valori & Exemplu \\ 
 \hline  \hline
 Unar & 1 & 111\\
 \hline
 Binar & 0, 1 & 1000\\ 
 \hline
 Decimal & [0, 9]  & 10\\ 
 \hline 
 Hexadecimal & $[0, 9] \cup [A, F]$ & B4\\ 
 \hline
\end{tabular}
\end{table}

Un alt aspect important, strâns legat de radix, este numărul de simboluri \textit{s} necesare pentru a reprezenta un număr oarecare \textit{n} în baza \textit{r}. Relația matematică care defineste acest aspect este redată prin formula \ref{Formula:1}.

\begin{equation}
\label{Formula:1}
s = log_r n
\end{equation}


\subsubsection{NUMERELE BINARE}
Modul de funcționare a dispozitivelor digitale  este constituit pe oscilațiile rapide ale semnalelor electrice, semnale a căror valori se identifică cu unul dintre membri faimosului cuplu binar, \textit{0 și 1}. Prin urmare, datele vor avea o reprezentare care utilizează radixul binar. 

Fiecare simbol dintr-un număr binar poarte numele de bit, un amalgam de 4 biți se numește nibble, iar o înșiruire de 2 nibble, echivalentă cu 8 biți, poartă numele de octet. Bit-ul care corespunde celui mai mare exponent de 2 poartă numele de \textit{msb}, iar bit-ul care corespunde celui mai mic exponent are denumirea de \textit{lsb}.

Conceptul de împărțire a unui numar binar în octeți ajuta reprezentarea acestora într-o bază numerică superioară, în special cea hexadecimală. Figura \ref{Figura:1} prezintă clar părtile constituente a unui octet și relația dintre acestea.

 \begin{figure}[h!]
 \centering
 \caption{Modul de împărțire a unui octet, părțile sale constituente}
 \label{Figura:1}
 \includegraphics[width=0.5\textwidth]{byte.png}
 \end{figure}

Octet-ul va reprezenta unitatea fundamentală și indivizibilă pentru microarhitectura microprocesorul dezvoltat prin această lucrare. Acesta, prin urmare, este cea mai mică entitate adresabilă cu care se va lucra. Un octet este limitat de numărul de date pe care le poate reprezenta, acestea fiind calculate prin exponentul $\ 2^n$, în cazul nostru, $\ 2^8$ sau 256 de valori.

Un lucru important de menționat este că valoarea maximă a unui număr pe \textit{n} biți va fi mereu $\ 2^n -1$. Prin urmare, dacă dorim să reprezentăm o putere oarecare $\ 2^n$, vor fi necesari $\ n +1$ biți de date.
Tabelul \ref{Tabela:2} prezintă realația dintre magnitudinea binară (număul de biți folosiți în reprezentare) și cantitata de date reprezentate prin plaja de valori adiacentă, ignorând existenta numerelor negative.

\begin{table}[h]
\centering
\caption{Plaja de valori asumând numere strict pozitive, de magnitudini binare diverse }
\label{Tabela:2}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Biți de date & Numărul datelor & Interval valori \\ 
 \hline  \hline
 8 & 256 & $\ 0 \le n \le 2^{8} - 1$ \\
 \hline
 16 & 65536 & $\ 0 \le n \le 2^{16} - 1$ \\
 \hline
 32 &  $\ 2^{32}$ & $\ 0 \le n \le 2^{32} - 1$ \\
 \hline
 64 & $\ 2^{64}$ & $\ 0 \le n \le 2^{64} -1$ \\
 \hline
\end{tabular}
\end{table}

\subsubsection{BAZA HEXADECIMALĂ}
Datorită clarificării reprezentării datelor în radix-ul binar, întelegerea bazei hexadecimale va fi cu atât mai simplă. Convertirea unui număr din binar in hexadecimal se face pe baza împărțirii acestuia în serii de \textit{nibble}. În situația când reprezentarea binară nu are destui biți pentru a acomoda o așa diviziune a sa, se completează cu diferența de simboluri de 0 necesare. Tabela \ref{Tabela:3} prezintă valorile care vor fi utilizate în conversie cât și echivalența dintre baza binară, decimală și hexadecimală.

\begin{table}[h]
\centering
\caption{Echivalența nibble - simbol hexadecimal }
\label{Tabela:3}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Nibble & Simbol & Decimal\\ 
 \hline  \hline
 0000 & 0 & 0\\
 \hline
 0001 & 1 & 1\\
 \hline
 0010 & 2 & 2\\
 \hline
 0011 &  3 & 3\\
 \hline
 0100 & 4 & 4\\
 \hline
 0101 & 5 & 5 \\
 \hline
 0110 & 6 & 6\\
 \hline
 0111 & 7 & 7\\
 \hline
 1000 & 8 & 8\\
 \hline
 1001 & 9 & 9\\
 \hline
 1010 & A & 10\\
 \hline
 1011 & B & 11\\
 \hline
 1100 & C & 12\\
 \hline
 1101 & D & 13\\
 \hline
 1110 & E & 14\\
 \hline
 1111 & F & 15\\
 \hline
\end{tabular}
\end{table}

\subsubsection{OPERAȚIILE MATEMATICE ȘI NUMERELE BINARE}
Pentru a utiliza în mod corect reprezentările în această bază, modul în care calculele matematice sunt efectuate asupra numerelor binare necesită clarificare.

Datele nu sunt folositoare doar prin existența lor. Pentru a dobândi utilitate, acestea sunt supuse aparatului matematic, prin care se calculează diverse valori, asumând un algoritm corect, care ne oferă informații despre problema pe care dorim să o rezolvăm.

Cea mai elementară operație matematică care poate fi aplicată unui număr este adunarea. Însumarea numerelor este cu atât mai facilă cu cât numărul de simboluri folosite în reprezentarea acestora scade. Spre norocul lumii digitale, radix-ul utilizat permite efectuarea operațiilor matematice în cele mai simple metode. Există doar $\ 4$ operații fundamentale posibile, acestea fiind prezentate în Tabela \ref{Tabela:3}.

\begin{table}[h]
\centering
\caption{Operațiile fundamentale de însumare a numerelor binare }
\label{Tabela:4}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Operație & Sumă & Carry \\ 
 \hline  \hline
 0 + 0 & 0 & 0\\
 \hline
 0 + 1 & 1  & 0\\
 \hline
 1 + 0 &  1 & 0 \\
 \hline
 1 + 1 & 0 & 1 \\
 \hline
\end{tabular}
\end{table}
Dintre toate aceste operații, cea căreia îi vom oferi o importanță ridicată este $\ 1 + 1 = 0$ \textit{carry} 1. Aceasta  ne obligă să adunăm o unitate bițiilor de pe poziții superioare. Practic, acestă sumă, odată ce este generalizată, ne spune că $\ 2^n + 2^n = 2 \cdot 2^n = 2^{n+1}$, o trivialitate matematică. Diverse exemple de adunare ale numerelor binare pot fi consultate în Figura \ref{Figura:2}.

 \begin{figure}[h!]
 \centering
 \caption{Exemple de adunare a numerelor binare}
 \label{Figura:2}
 \includegraphics[width=0.9\textwidth]{binary_addition.png}
 \end{figure}

\subsubsection{REPREZENTAREA NUMERELOR NEGATIVE}
Modul în care numerele positive sunt adunate fiind acum clarificat, următoara operație matematică tratată este scăderea. Aceasta poate fi vizualizată ca adunarea unui numar \textit{a} la inversul aditiv al altui număr \textit{b}.
Această operație cere prin urmare un mod de reprezentare al numerelor binare negative, soluție care vine prin trei metode.

Primul mod de reprezentare este cel prin semn-magnitudine. Acesta este intuitiv, fiind similar cu reprezentarea numerelor decimale cu semn. Bit-ul cel mai semnificativ devine acum bit-ul de semn, 1 reprezentând un număr negativă, iar 0 unul pozitiv. Tabelul \ref{Tabela:4} prezintă aplicarea acestei reprezentări asupra numerelor pe 8 biți.

\begin{table}[h]
\centering
\caption{Reprezentarea prin semn-magnitudine }
\label{Tabela:5}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Valoare binară & Semn magnitudine &  Fără semn\\ 
 \hline  \hline
 00000000 & 0 & 0\\
 \hline
 00000001 & 1  & 1\\
 \hline
 00000010 &  2 & 2 \\
 \hline
  ... &  ... & ... \\
 \hline
 01111110 & 126 & 126 \\
 \hline
 01111111 & 127 & 127 \\
 \hline
 10000000 & -0 & 128 \\
 \hline
 10000001 & -1 & 129 \\
 \hline
 10000010 & -2 & 130 \\
 \hline
   ... &  ... & ... \\
 \hline
  11111101 & -125 & 253 \\
 \hline
 11111110 & -126 & 254 \\
 \hline
 11111111 & -127 & 255 \\
 \hline
\end{tabular}
\end{table}
Se pot astfel distinge următoarele lucruri:
\begin{itemize}
\item Există două reprezentări posibile pentru 0, și anume $\ \pm 0$.
\item Deși se acopera tot 255 de valori numerice posibile (256 cu cel de al doilea 0), plaja de valori \textit{signed} s-a distribuit egal numerelor negative și celor pozitive. Astfel, numerele \textit{unsigned} semn-magnitudine  sunt cuprinse în intervalul $\ [-2^{n-1}+1, 2^{n-1}-1]$ unde $\ n > 0$ 
\end{itemize}

O altă medotă de reprezentare este prin complementul de 1. Conform acesteia, se inversează biții numărului binar pozitiv (biții cu valoarea 1 vor deveni 0 și viceversa) rezultând astfel inversul său aditiv. Spre exemplu, $\ 00000001' = 11111110;$ $\ 01010101' = 10101010$ iar, în cazul lui 0, $\ 00000000' = 11111111$. Tabela \ref{Tabela:5} conține reprezentările numerelor de 8 biți.
\begin{table}[h]
\centering
\caption{Reprezentarea prin complement de 1 }
\label{Tabela:6}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Valoare binară & Semn magnitudine &  Fără semn\\ 
 \hline  \hline
 00000000 & 0 & 0\\
 \hline
 00000001 & 1  & 1\\
 \hline
 00000010 &  2 & 2 \\
 \hline
  ... &  ... & ... \\
 \hline
 01111110 & 126 & 126 \\
 \hline
 01111111 & 127 & 127 \\
 \hline
 10000000 & -127 & 128 \\
 \hline
 10000001 & -126 & 129 \\
 \hline
 10000010 & -125 & 130 \\
 \hline
   ... &  ... & ... \\
 \hline
  11111101 & -2 & 253 \\
 \hline
 11111110 & -1 & 254 \\
 \hline
 11111111 & -0 & 255 \\
 \hline
\end{tabular}
\end{table}

La fel ca în cazul reprezentării prin semn-magnitudine, 0 dorește să respecte principiul superpoziției, diferența pricipală însă, precum se distinge din compararea Tabelei \ref{Tabela:5} cu  Tabela \ref{Tabela:4}, este faptul ca valorile negative sunt eșalonate invers.

Problema acestor reprezentări este cu atât mai vizibilă când se efectuează adunarea a două numere binare, rezultatul fiind mereu $\ 111..1..111$, unda dintre reprezentările posibile ale lui 0. Soluția vine prin complementul de 2, complement format prin adăugarea unei unități reprezentării complementare de 1. Efectul însumării unitare este cel mai bine explicitat de Figura \ref{Figura:3}.
 
 \begin{figure}[h!]
 \centering
 \caption{Efectul adunării unității asupra complementului de 1}
 \label{Figura:3}
% https://q.uiver.app/#q=WzAsMjYsWzQsMCwiMDAwMDAwMDAgPSAxMTExMTExMSJdLFs0LDEsIjAiXSxbNCw0LCIwIl0sWzQsMywiMDAwMDAwMDAiXSxbMiw0LCIuLi4iXSxbMiwxLCIuLi4iXSxbNiwxLCIuLi4iXSxbNiw0LCIuLi4iXSxbMCw0LCItMTI4Il0sWzMsNCwiLTEiXSxbNSw0LCIxIl0sWzUsMywiMDAwMDAwMDEiXSxbNyw0LCIxMjciXSxbNywzLCIwMTExMTExMSJdLFs1LDEsIjEiXSxbNSwwLCIwMDAwMDAwMSJdLFs3LDEsIjEyNyJdLFs3LDAsIjAxMTExMTExIl0sWzMsMSwiLTEiXSxbMywwLCIxMTExMTExMCJdLFszLDMsIjExMTExMTExIl0sWzEsMSwiLTEyNyJdLFsxLDQsIi0xMjciXSxbMSwwLCIxMDAwMDAwMCJdLFsxLDMsIjEwMDAwMDAwIl0sWzAsMywiMTAwMDAwMDAiXSxbMiw5XSxbMiwxMF0sWzEwLDddLFs3LDEyXSxbMSwxNF0sWzE0LDZdLFs2LDE2XSxbMSwxOF0sWzE4LDIwLCIrMSIsMV0sWzIwLDldLFsxOCw1XSxbOSw0XSxbNSwyMV0sWzQsMjJdLFsyMiw4XSxbMjEsMjQsIisxIiwxXSxbMjQsMjJdXQ==
\[\begin{tikzcd}[cramped,column sep=tiny,row sep=scriptsize]
	& 10000000 && 11111110 & {00000000 = 11111111} & 00000001 && 01111111 \\
	& {-127} & {...} & {-1} & 0 & 1 & {...} & 127 \\
	\\
	10000000 & 10000000 && 11111111 & 00000000 & 00000001 && 01111111 \\
	{-128} & {-127} & {...} & {-1} & 0 & 1 & {...} & 127
	\arrow["{+1}"{description}, from=2-2, to=4-2]
	\arrow[from=2-3, to=2-2]
	\arrow[from=2-4, to=2-3]
	\arrow["{+1}"{description}, from=2-4, to=4-4]
	\arrow[from=2-5, to=2-4]
	\arrow[from=2-5, to=2-6]
	\arrow[from=2-6, to=2-7]
	\arrow[from=2-7, to=2-8]
	\arrow[from=4-2, to=5-2]
	\arrow[from=4-4, to=5-4]
	\arrow[from=5-2, to=5-1]
	\arrow[from=5-3, to=5-2]
	\arrow[from=5-4, to=5-3]
	\arrow[from=5-5, to=5-4]
	\arrow[from=5-5, to=5-6]
	\arrow[from=5-6, to=5-7]
	\arrow[from=5-7, to=5-8]
\end{tikzcd}\]
\end{figure}
Din această figură se observa următoarele:
\begin{itemize}
\item În cazul complementului de 2, nu mai există două reprezentări posibile pentru 0, locul suplimentar fiind luat de posibilitatea reprezentării unui număr negativ adițional, $\ -128$.
\item Intervalul posibil de valori devine acum  $\ [-2^{n-1}, 2^{n-1}-1]$.
\end{itemize}

Odată cu clarificarea reprezentării numerelor binare negative, operațiile matematice fundamentale pe care microprocesorul modelat pe decursul acestei lucrări le va utiliza, pot fi acum implementate. Însă, pentru a face legătura dintre abstractul arhitectural al sistemului și datele numerice, este necesară tratarea entităților digitale fundamentale cunoscute drept porți logice. 

\subsection{ABSTRACȚIA LOGICĂ} 

Porțile logice sunt acele dispozitive care fac legătura dintre operațiile matematice abstracte definite anterior și implementarea propriu zisă a sistemului practic de calcul. În spatele unei porți logice se găsesc tranzistoarele, mici întrerupătoare electrice ale căror mărime a ajuns în zilele noastre să atingă ordinul nanometric (\textit{$\ 10^{-9}$ metri}). Subtilitățile de  funcționare ale unui tranzistor sunt dincolo de scopul acestei lucrări, acesta fiind considerat cutia neagră de la baza implementării entităților digitale.

O poartă logică are rolul de a implementa o funcție matematică a algebrei Booleane. Comportamentul acestora este considerat ideal, întârzierile de propagare a impulsului astfel neglijabile. Pentru analiza funcției algebrice descrise se vor utiliza  tabele logice,a căror rol este de a relaționa în format tabelar semnalele de intrare cu rezultatul produs.

Un amalgam de porți logice cumulat după operația definită de o funcție algebrică formează un sistem logic de o complexitate variată. Printre acestea se număra dispozitivele de memorare, de la \textit{flip-flop-uri} și \textit{bistabile} la \textit{RAM} și \textit{ROM}, dar și cele aritmetice precum \textit{ALU} (unitatea aritmetică logică) și \textit{FPU} (coprocesorul pentru numere cu virgulă flotantă).


\subsubsection{BUFFER}
Un buffer reprezintă cea mai simplă poartă logică. Rolul acesteia este de a transmite exact semnalul pe care-l primește ca intrare, adaugând însă o întârziere de propagare. Simbolul porții logice este prezentat de Figura \ref{Figura:4}.

 \begin{figure}[h!]
 \centering
 \caption{Simbolul porții logice Buffer}
 \label{Figura:5}
\begin{tikzpicture}[thick,scale=2.0, every node/.style={transform shape}]
    \node (x) at (0, 1) {$A$};
    \node (y) at (1.9, 1) {$Q$};
    \node[buffer gate US, draw] at ($(x) + (0.8, 0)$) (notx) {};
    \draw (x) -- (notx.input);
    \draw (notx.output) -- ++(0.4, 0);
\end{tikzpicture}
\end{figure}
 
 Utilitatea acesteia se poate observa în special la nivelul procesoarelor  multi-cycle, buffer-ul având un rol important în organizarea modului de execuție a instrucțiunilor complexe care necesită multiple cicluri de tact. 
 
\subsubsection{NOT}
De asemenea cunoscut sub numele de \textit{inversor}, rolul acestei porți logice este 
de a schimba polaritatea semnalului primit.
 
 \begin{table}[h]
\centering
\caption{Funcția logică NOT}
\label{Tabela:7}
\begin{tabular}{ ||c|c|| }
 \hline
 A & Q\\ 
 \hline  \hline
 1 & 0 \\
 \hline
 0 & 1 \\
 \hline
\end{tabular}
\end{table}

Tabela \ref{Tabela:7} prezintă functionalitatea acestei porți. Simbolul utilizat în diagramele circuitelor este prezentat prin Figura \ref{Figura:5}. Ecuația matematică a inversorului este $\ Q = \overline{A}$.


 \begin{figure}[h!]
 \centering
 \caption{Simbolul porții logice NOT}
 \label{Figura:5}
\begin{tikzpicture}[thick,scale=2.0, every node/.style={transform shape}]
    \node (x) at (0, 1) {$A$};
    \node (y) at (1.9, 1) {$Q$};
    \node[not gate US, draw] at ($(x) + (0.8, 0)$) (notx) {};
    \draw (x) -- (notx.input);
    \draw (notx.output) -- ++(0.4, 0);
\end{tikzpicture}
\end{figure}
 
\subsubsection{SAU}
Poarta logică \textit{sau} reprezintă implementarea operației de disjuncție matematică, a cărei rezultat este 0 doar atunci când ambele intrări logice sunt 0. Tabela \ref{Tabela:8} prezintă valorile operației raportate la intrările logice. Expresia matematică a operației \textit{sau} este $\ Q = A+B$.
 \begin{table}[h]
\centering
\caption{Funcția logică SAU}
\label{Tabela:8}
\begin{tabular}{ ||c|c|c|| }
 \hline
 A & B & Q\\ 
 \hline  \hline
 1 & 1 & 1 \\
 \hline
 1 & 0 & 1 \\
 \hline
 0 & 1 & 1 \\
 \hline 
 0 & 0 & 0 \\
 \hline
\end{tabular}
\end{table}

Simbolul utilizat în diagramele circuitelor este prezentat prin Figura \ref{Figura:6}.

 \begin{figure}[h!]
 \centering
 \caption{Simbolul porții logice SAU}
 \label{Figura:6}
    \begin{tikzpicture}[thick,scale=2.0, every node/.style={transform shape}]
    \node[or gate US, minimum size = 28pt, draw] at (1.5,0.5) (NAND) {};
	\node[label={[above] left:$A$}] at ([xshift=-0.6cm]NAND.input 1) (A) {};
	\node[label={[below] left:$B$}] at ([xshift=-0.6cm]NAND.input 2) (B) {};
	\draw (A.east) -- (NAND.input 1);
	\draw (B.east) -- (NAND.input 2);
    \draw (NAND.output) -- ($(NAND) + (1.2,0)$);
    \node (z) at ($(NAND) + (1.5,0)$) {$Q$};
    \end{tikzpicture}
 \end{figure}
 
\subsubsection{ȘI}
Poarta logică \textit{și} reprezintă implementarea operației de conjuncție matematică, a cărei rezultat este 1 doar atunci când ambele intrări logice sunt 1. Tabela \ref{Tabela:9} prezintă valorile operației raportate la intrările logice. Expresia matematică a operației \textit{și} este $\ Q = A \cdot B$.
 \begin{table}[h]
\centering
\caption{Funcția logică ȘI}
\label{Tabela:9}
\begin{tabular}{ ||c|c|c|| }
 \hline
 A & B & Q\\ 
 \hline  \hline
 1 & 1 & 1 \\
 \hline
 1 & 0 & 0 \\
 \hline
 0 & 1 & 0 \\
 \hline 
 0 & 0 & 0 \\
 \hline
\end{tabular}
\end{table}

Simbolul utilizat în diagramele circuitelor este prezentat prin Figura \ref{Figura:7}.

 \begin{figure}[h!]
 \centering
 \caption{Simbolul porții logice ȘI}
 \label{Figura:7}
    \begin{tikzpicture}[thick,scale=2.0, every node/.style={transform shape}]
    \node[and gate US, minimum size = 28pt, draw] at (1.5,0.5) (NAND) {};
	\node[label={[above] left:$A$}] at ([xshift=-0.6cm]NAND.input 1) (A) {};
	\node[label={[below] left:$B$}] at ([xshift=-0.6cm]NAND.input 2) (B) {};
	\draw (A.east) -- (NAND.input 1);
	\draw (B.east) -- (NAND.input 2);
    \draw (NAND.output) -- ($(NAND) + (1.2,0)$);
    \node (z) at ($(NAND) + (1.5,0)$) {$Q$};
    \end{tikzpicture}
 \end{figure}

\subsubsection{XOR}
Poarta logică \textit{xor}, de asemenea cunoscută ca \textit{SAU exclusiv} setează semnalul de output pe 1 logic doar în cazul în care cel mult una dintre intrări este activă. Comportamentul acesteia este cel mai bine reprezentat de Tabela \ref{Tabela:10}. Expresia matematică care descrie această poartă este $\ Q = A \oplus B$.
\begin{table}[h]
\centering
\caption{Funcția logică XOR}
\label{Tabela:10}
\begin{tabular}{ ||c|c|c|| }
 \hline
 A & B & Q\\ 
 \hline  \hline
 1 & 1 & 0 \\
 \hline
 1 & 0 & 1 \\
 \hline
 0 & 1 & 1 \\
 \hline 
 0 & 0 & 0 \\
 \hline
\end{tabular}
\end{table}


Această operație logică implică practic excluderea mutuală a semnalelor de intrare, indiferent de numărul acestora. Simbolul logic utilizat în diagramele digitale se poate regăsi în Figura \ref{Figura:8}.
 \begin{figure}[h!]
 \centering
 \caption{Simbolul porții logice XOR}
  \label{Figura:8}
    \begin{tikzpicture}[thick,scale=2.0, every node/.style={transform shape}]
    \node[xor gate US, minimum size = 28pt, draw] at (1.5,0.5) (NAND) {};
	\node[label={[above] left:$A$}] at ([xshift=-0.6cm]NAND.input 1) (A) {};
	\node[label={[below] left:$B$}] at ([xshift=-0.6cm]NAND.input 2) (B) {};
	\draw (A.east) -- (NAND.input 1);
	\draw (B.east) -- (NAND.input 2);
    \draw (NAND.output) -- ($(NAND) + (1.2,0)$);
    \node (z) at ($(NAND) + (1.5,0)$) {$Q$};
    \end{tikzpicture}
 \end{figure}

\newpage
\subsubsection{NAND}
Ca o regulă generala, totalitatea porților logice la ale căror denumire se atașează prefixul \textit{N-} sunt varianta negată a portii logice originale. Însă, spre deosebire de restul porților, NAND este de asemenea cunoscută ca și poarta logică fundamentală. Această denumire reiese din operațiile algebrei Booleane.

 În mod firesc, semnalul de ieșire al acestei porți va fi complementarul operației \textit{and}. La nivelul Tabelei \ref{Tabela:11} se poate observa acest lucru. Expresia matematică a acestei operații este  $\ Q = \overline{A \cdot B}$.
 \begin{table}[h]
\centering
\caption{Funcția logică NAND}
\label{Tabela:11}
\begin{tabular}{ ||c|c|c|| }
 \hline
 A & B & Q\\ 
 \hline  \hline
 1 & 1 & 0 \\
 \hline
 1 & 0 & 1 \\
 \hline
 0 & 1 & 1 \\
 \hline 
 0 & 0 & 1 \\
 \hline
\end{tabular}
\end{table}

Simbolul utilizat în diagramele circuitelor este prezentat prin Figura \ref{Figura:7}.
 \begin{figure}[h!]
 \centering
 \caption{Simbolul porții logice NAND}
 \label{Figura:9}
    \begin{tikzpicture}[thick,scale=2.0, every node/.style={transform shape}]
    \node[nand gate US, minimum size = 28pt, draw] at (1.5,0.5) (NAND) {};
	\node[label={[above] left:$A$}] at ([xshift=-0.6cm]NAND.input 1) (A) {};
	\node[label={[below] left:$B$}] at ([xshift=-0.6cm]NAND.input 2) (B) {};
	\draw (A.east) -- (NAND.input 1);
	\draw (B.east) -- (NAND.input 2);
    \draw (NAND.output) -- ($(NAND) + (1.2,0)$);
    \node (z) at ($(NAND) + (1.5,0)$) {$Q$};
    \end{tikzpicture}
 \end{figure}
 
\subsubsection{MULTIPLEXARE}
Pe lângă circuitele clasice reprezentate de porțile logice, un alt component digital, multiplexorul, merită studiat, acesta având o importanță deosebită. Prin multiplexare se întelege selecția unui anumite intrări dintr-o lista de \textit{n} posibilități. Selecția este dictată de un alt semnal de intrare numit selecție sau selector.

Multiplexara de asemenea are o operație opusă, aceasta purtând numele de demultiplexare. Dintr-o listă de \textit{n} ieșiri posibile, se va alege conform semnalului selector drumul pe care-l va lua un semnal de intrare.

Atunci când se dorește utilizarea unui dispozitiv multiplexor, cel mai important parametru este reprezentat de numărul de intrări specificate de cazul de utilizare. Conform acestor \textit{n} intrări, se va calcula utilizând expresia $\log_2{n}$ biții necesari semnalului de selecție.

Figura \ref{Figura:24} arată modul de reprezentare grafic al unui multiplexor cu 4 intrări pe 32 de biți și un semnal de selecție de 2 biți.
 \begin{figure}[h]
 \centering
 \caption{Diagrama logică a unui multiplexor}
 \label{Figura:24}
 \includegraphics[width=0.5\textwidth]{mux41.png}
 \end{figure}
 

 \subsection{ABSTRACTIA ARHITECTURALĂ}
Arhitectura face legătura dintre microarhitectura sistemului și programatorul care dorește să-l utilizeze. Acest nivel de abstracție are rolul de a oferi un ghid asupra interacțiunii cu interfața definită de standardul RISC-V. Prin urmare, vor analiza detalile arhitecturii, printre care se numără structura organizațională a registrelor, tipurile de instrucțiuni cât si modul în care octeții sunt organizați la nivelul acestora. Ne vom limita însă la extensia de bază RISC-V care include doar instrucțiunile fundamentale asupra numerelor întregi.

\subsubsection{FIȘIERUL DE REGISTRE}
  Cel mai important detaliu microarhitectural este fișierul de registre. Acesta este singurul dintre elementele de design a cărei respectare a tiparului impus de standardul RISC-V este imperativă.
  
   Standardul impune un fișiser de 32 de registre în cazul setului RV32I și 32 sau 64 de registre, în funcție de mărimea spațiului de adresare, pentru un procesor RV64I. Denumirea acestor registre, conform convenției, îndică modul destinat de utilizare dar, nu există constrângeri la doar astfel de utilizări.
   
Tabela \ref{Tabela:12} ne ajută să identificăm registrele procesorului RV32I cât și utilizarea acestora. Coloana \textit{Denumire Simbolică} prezintă modul de adresarea ale acestor registre la nivelul limbajului de asamblare.

\begin{table}[h]
\centering
\caption{Fișierul de registre RV32I}
\label{Tabela:12}
\begin{tabular}{ ||c|c|c|| }
 \hline
 Registru & Denumire simbolică & Descriere\\ 
 \hline  \hline
 x0 & zero & Legat la valoarea 0 \\
 \hline
 x1 & ra & Adresa de return \\
 \hline
 x2 & sp & Pointer stivă \\
 \hline 
 x3 & gp & Pointer global \\
  \hline
 x4 & tp & Pointer thread \\
  \hline  
 x5-7 & t0-2 & Valori temporare \\
 \hline
 x8 & fp & Stocare date sau pointer cadru \\
  \hline  
 x9 & s1 & Stocare date \\
  \hline  
 x10-11 & a0-1 & Argumente apel funcție sau valori de return \\
  \hline  
 x12-17 & a2-7 & Argumente apel funcție \\
  \hline  
 x18-27 & s2-11 & Stocare date \\
  \hline  
 x28-31 & t3-6 & Valori temporare \\
  \hline  
\end{tabular}
\end{table}

\subsubsection{INSTRUCȚIUNILE DE BAZĂ RISC-V}

Operațile de bază executate de un procesor RV32I sunt transcrise în instrucțiuni având o mărime de 4 octeți. Aceste instrucțiuni pot fi de următoarele tipuri:

\begin{itemize}
\item Instrucțiuni R, \textit{Register-Register}, pentru operațile de la registru la registru.
\item Instrucțiuni I, \textit{Immediate}, pentru operații asupra valorilor imediate.
\item Instrucțiuni S, \textit{Store}, cu rol de încărcare a datelor în memoria volatilă.
\item Instrucțiuni U, \textit{Upper Immediate}, cu rol de încarcare imediată a octeților cei mai semnificativi în registre.
\end{itemize}

\subsubsection{INSTRUCȚIUNEA R}
Instrucțiunile de acest format adresează 3 registre, 2 dintre ele fiind sursa datelor, cel de al 3-lea reprezentând destinația. Acestea sunt în general utilizate în operațile aritmetice, precum adunarea și scăderea numerelor. Figura \ref{Figura:10} prezintă formatul acestei instrucțiuni cât și câmpurile de date constituente.



 \begin{figure}[h!]
 \centering
 \caption{Instrucțiunea R și câmpurile de date}
 \label{Figura:10}
 \includegraphics[width=0.5\textwidth]{rtype.drawio.png}
 \end{figure}

 Campurile acestei instrucțiuni au următoarele semnificații:
 \begin{itemize}
\item Câmpul \textit{opcode} indică tipul instrucțiinii care va fi executată de ALU.
\item Câmpul \textit{rd} conține adresa registrului unde va fi stocat rezultatul operației.
\item Câmpul \textit{rs1} conține adresa registrului primului operand.
\item Câmpul \textit{rs2} conține adresa registrului celui de al 2-lea operand.
\item Câmpurile \textit{funct7} și \textit{funct3} conțin date adiționale pentru operația aritmetică de executat.
\end{itemize}

Un exemplu practic al acestei instrucțiuni se poate vedea în Figura \ref{Figura:11}. Datele din registrele 1 și 2 sunt însumate, rezultatul fiind plasat în registrul 3.

 \begin{figure}[h!]
 \centering
 \caption{Exemplu de utilizare al instrucțiunii R}
 \label{Figura:11}
 \includegraphics[width=0.5\textwidth]{rtypeexample.png}
 \end{figure}

\subsubsection{INSTRUCȚIUNEA S}
Rolul instrucțiunilor de acest format este stocarea datelor. Pentru a facilita acest lucru, formatul instrucțiunii include 2 registre și câmpul imediat. Un registru este utilizat în calculul adresei de memorie, alături de un offset reprezentat de datele imediate, cel doilea conținând datele care se doresc stocate. Figura \ref{Figura:12} arată structura unei astfel de instrucțiuni.
 \begin{figure}[h!]
 \centering
 \caption{Instrucțiunea R și câmpurile de date}
 \label{Figura:12}
 \includegraphics[width=0.5\textwidth]{stype.png}
 \end{figure}
 
Semnificația câmpurilor este următoarea:
 \begin{itemize}
\item Câmpul \textit{opcode} indică tipul instrucțiinii de executat.
\item Câmpul \textit{rs1} conține adresa registrului în care se găsesc datele destinate stocării.
\item Câmpul \textit{rs2} conține adresa registrului față de a cărui valoare se va calcula offset-ul.
\item Câmpul \textit{funct3} conțin date adiționale despre operația de \textit{store} executată.
\item Câmpul \textit{Immediate} format din \textit{imm1} și \textit{imm2}, în această ordine,  reprezintă offset-ul adresei în care de dorește stocarea.
\end{itemize}


Un exemplu practic al acestei instrucțiuni se poate vedea în Figura \ref{Figura:13}. Valoarea din registrul 1 va fi stocată la adresa indicată de registrul 2, la care se va adauga un offset de \textit{-1}.

 \begin{figure}[h!]
 \centering
 \caption{Instrucțiunea R și câmpurile de date}
 \label{Figura:13}
 \includegraphics[width=0.5\textwidth]{stypeexample.png}
 \end{figure}
 
 \subsubsection{INSTRUCȚIUNEA I}
 Instrucțiunea I are rol în execuția operaților aritmetice cu valori imediate. Aceste valori sunt extinse la 32 de biti, ele ocupând doar 12 biți din lătimea instrucțiunii. În urma extensiei de semn, se efectueaza operația aritmetică specificată prin câmpul \textit{funct3} cu registrul \textit{rs1}, rezultatul fiind stocat în registrul \textit{rd}. Figura \ref{Figura:14} prezintă structura instrucțiunii și câmpurile relevante.

 \begin{figure}[h!]
 \centering
 \caption{Instrucțiunea I și câmpurile de date}
 \label{Figura:14}
 \includegraphics[width=0.5\textwidth]{itype.png}
 \end{figure}

 Fie o valoare imediată egală cu \textit{5}, se dorește însumarea sa cu valoare din registrul \textit{1}, rezultatul operației fiind trimis registrului \textit{3}. Un astfel de exemplu se poate vedea în Figura \ref{Figura:15}

 \begin{figure}[h!]
 \centering
 \caption{Instrucțiunea I și câmpurile de date}
 \label{Figura:15}
 \includegraphics[width=0.5\textwidth]{itype.png}
 \end{figure}
 
 \subsubsection{INSTRUCȚIUNEA U}
 Această instrucțiune este folositoare atunci când se dorește de către programator încărcarea unei valori imediate într-un registru, vizată ulterior unor calcule. Formatul instrucțiunii are în compoziția sa câmpul datelor imediate, întins pe 20 de biți, registrul destinație și codul identificator al operației de executat. Cei 20 de biți sunt cei mai semnificativi ai numărului imediat, urmând ca acesta să fie extins la 32 de biți. Aranjamentul anterior descris poate fi observat în Figura \ref{Figura:22}.
 \begin{figure}[h!]
 \centering
 \caption{Instrucțiunea U și câmpurile de date}
 \label{Figura:22}
 \includegraphics[width=0.5\textwidth]{utype.png}
 \end{figure}

Figura \ref{Figura:23} prezintă un exemplu de utilizare, în registrul 5 fiind încărcată valoarea imediată 0X51AA3.

 \begin{figure}[h!]
 \centering
 \caption{Exemplu de utilizare al instrucțiunii U}
 \label{Figura:23}
 \includegraphics[width=0.5\textwidth]{utypeexample.png}
 \end{figure}
 
\newpage
\section{\centering IMPLEMENTARE}
\bigbreak
\subsection{ABSTRACȚIA MICROARHITECTURALĂ}
Microarhitectura reprezintă organizarea ierarhică și modulară a componentelor digitale prin care se realizează implementarea practică a unui microprocesor. Precum parcurgem acest nivel de abstracție, vor fi prezentate toate componentele de bază pe care un microprocesor le necesită pentru a funcționa la cel mai de bază nivel. Odată ce toate astfel de componente sunt definite, este posibilă organizarea lor conform arhitecturii RISC-V, rezultând astfel într-un procesor funcțional.

Componentele vor fi prezentate atât în format grafic, prin diagrame digitale, cât și prin codul aferent entității VHDL. Testarea entităților se va face printr-un \textit{testbench} VHDL, fiind prezentate formele de undă caracteristice.

 \subsubsection{SUMATORUL ȘI ARITMETICA NUMERELOR}
 Cea mai necesară operație pe care un sistem de calcul digital o poate executa este adunarea. Pe baza circuitului sumator se vor constitui alte componente digitale, precum \textit{program counter-ul}. Din cauza utilizării extensive a circuitelor sumatoare, acestea sunt adesea ținta unei multitudini de optimizări, rezultând astfel circuite de o complexitate digitală mai ridicată, dar cu o amprentă temporală redusă.
 
Sumatorul implementat în această lucrare este de tipul ripple adder, carry-ul propagându-se de la un full adder la altul. Avantajul acestei implementări este ușurința modelării hardware, dezavantajul fiind lipsa de optimizare temporală și spațială a operației.

Schema digitală a unui sumator full adder poate fi observată în Figura \ref{Figura:16}. Acesta are rolul de a executa suma a 2 biți, precum s-a prezentat la nivelul abstracției numerice.

 \begin{figure}[h!]
 \centering
 \caption{Sumator integral și structura sa internă}
 \label{Figura:16}
 \includegraphics[width=0.9\textwidth]{fulladder.png}
 \end{figure}

Implementarea VHDL a entității cât și a arhitecturii sumatorului integral este redată prin secvența de cod aferentă Figurii \ref{Figura:25}. Se observă faptul că acestă entitate este construită prin relaționarea a două sumatoare pe jumătăți și a unei porți logice \textit{sau}.

 \begin{figure}[h!]
 \centering
 \caption{Entitatea și arhitectura VHDL a sumatorului integral}
 \label{Figura:25}
 \includegraphics[width=0.9\textwidth]{fulladderVHDL.png}
 \end{figure}

Prin legarea serială a 8 sumatoare, rezultă entitatea fundamentală de adunare a procesorului nostru, și anume sumatorul de octeți sau \textit{byte adder}. Structura acestuia este prezentată în Figura \ref{Figura:17}. Se poate observa faptul ca cele 8 sumatoare sunt împărține în două grupuri de 4, fiecare numit \textit{nibble adder}.
 \begin{figure}[h!]
 \centering
 \caption{Sumator de octeți si elementele constituente}
 \label{Figura:17}
 \includegraphics[width=0.9\textwidth]{byteadder.png}
 \end{figure}

Sumatorul de 32 de biți, cunoscut de asemenea ca sumatorul de cuvinte sau \textit{word adder} este prin urmare alcătuit din 4 sumatoare de octeți și poate fi văzut în Figura \ref{Figura:18}.

 \begin{figure}[h!]
 \centering
 \caption{Sumator ripple carry adder de 32 de biți}
 \label{Figura:18}
 \includegraphics[width=0.9\textwidth]{32bitadder.png}
 \end{figure}
 
Pentru a efectua operația de scădere, sunt necesare mai multe lucruri. În primul rând, avem nevoie de un inversor pentru a reprezenta forma complementară a numărului de scăzut. Pe lângă acest lucru, este necesar un multiplexor 2:1, a cărui rol este selecția între numărul inversat și valoarea sa inițială, în funcție de operația dorită. Tabela \ref{Tabela:13} prezintă modul în care va funcționa o astfel de operație.

\begin{table}[h]
\centering
\caption{Efectuarea operaților în funcție de selecția multiplexorului}
\label{Tabela:13}
\begin{tabular}{ ||c|c|c|c|c|| }
 \hline
 A & B & Carry & Sel & Operație\\ 
 \hline  \hline
 0x0406001F & 0x031400A5 & 0 & 0 & Adunare \\
 \hline
 0x0013121F & 0x01144EB5 & 1 & 1 & Scădere \\
 
  \hline  
\end{tabular}
\end{table}

Se poate observa faptul că semnalul de \textit{carry} este setat pe 1 în cazul scăderii. Acest lucru formează practic complementul de 2 necesar scăderii, numarul fiind doar inversat în prealabil, rezultând un complement de 1.

\newpage
Prin comasarea inversorului, a multiplexorului și a sumatorului rezultă astfel ceea ce vom denumi motor aritmetic. Schema digitală a acestuia se poate regăsi în Figura \ref{Figura:19}.

 \begin{figure}[h!]
 \centering
 \caption{Motorul aritmetic}
 \label{Figura:19}
 \includegraphics[width=0.9\textwidth]{ArithmeticEngine.png}
 \end{figure}
 
 \subsubsection{OPERAȚII LOGICE ȘI UNITATEA LOGIC}
 
 Pe lângă operațile aritmetice, un procesor de asemenea are posibilitatea de executare a operaților logice pe biți. Microprocesorul nostru va avea implementarea hardware a funcțiilor SAU, ȘI, XOR. Toate entitățile necesare efectuării acestor operații vor fi comasate într-un element hardware denumit motor logic.
 
Figura \ref{Figura:20} conține schema digitală a motorului logic cât și a elementelor care-l definesc, cele 3 porți logice pe 32 de biți ȘI, SAU, XOR.
  \begin{figure}[h!]
 \centering
 \caption{Motorul logic și entitățile interne}
 \label{Figura:20}
 \includegraphics[width=0.9\textwidth]{LogicEngine.png}
 \end{figure}
 
\newpage

\subsubsection{UNITATEA ARITMETICĂ ȘI LOGICĂ}

Unitatea aritmetică și logică este prima entitate ierarhică superioară pe care o vom reprezenta. Aceasta este formată din entitățile logice definite în prealabil, precum motorul logic și cel aritmetic, dar conține de asemenea elementul pentru detecție de \textit{overflow}, entitate care îi sporește gradul de utilitate.

 
\begin{figure}[h!]
 \centering
 \caption{Unitatea aritmetică și logică}
 \label{Figura:21}
 \includegraphics[width=0.9\textwidth]{ALU.png}
 \end{figure}

\end{document}